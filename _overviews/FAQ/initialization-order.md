---
layout: multipage-overview
title: Why is my abstract or overridden val null?
overview-name: FAQ
permalink: /tutorials/FAQ/:title.html
---

## Example

The following example illustrates the problem:

    abstract class A {
      val x1: String
      val x2: String = "mom"

      println("A: " + x1 + ", " + x2)
    }
    class B extends A {
      val x1: String = "hello"

      println("B: " + x1 + ", " + x2)
    }
    class C extends B {
      override val x2: String = "dad"

      println("C: " + x1 + ", " + x2)
    }

In the Scala REPL we observe:

    scala> new C
    A: null, null
    B: hello, null
    C: hello, dad

Only when we get to the constructor of `C` are both `x1` and `x2` initialized. Therefore, constructors of `A` and `B` risk running into `NullPointerException`s.

## Explanation

A "strict" or "eager" val is one which is not marked lazy.
Initialization of strict vals is done in the following order:

1. Superclasses are fully initialized before subclasses.
2. Otherwise, in declaration order.

When a `val` is overridden, in fact its accessor method (the "getter") is overridden.
So the access to `x2` in class `A` in fact invokes the overridden getter in class `C` which reads the underlying field `C.x2`.
This field is not yet initialized during the construction of `A`.

## Mitigation

The [`-Ysafe-init` compiler flag](https://docs.scala-lang.org/scala3/reference/other-new-features/safe-initialization.html) in Scala 3 enables compiler warnings for accesses to uninitialized fields:

    -- Warning: Test.scala:8:6 ------------------
    8 |  val x1: String = "hello"
      |      ^
      |      Access non-initialized value x1. Calling trace:
      |      ├── class B extends A {	[ Test.scala:7 ]
      |      │   ^
      |      ├── abstract class A {	[ Test.scala:1 ]
      |      │   ^
      |      └── println("A: " + x1 + ", " + x2)	[ Test.scala:5 ]
      |                          ^^

In Scala 2, the `-Xcheckinit` flag adds runtime checks in the generated bytecode to identify accesses of uninitialized fields.
The code then throws an exception rather than allowing a `null` (or `0` / `false` in the case of primitive types) to silently appear.
Note that these runtime checks only test code that is actually exectued at runtime.
The flag can be helpful to find accesses to uninitialized fields, but it should never be used in production due to its performance overhead.

## Solutions

Approaches for avoiding null values include:

### Use class / trait parameters

    abstract class A(val x1: String, val x2: String = "mom") {
      println("A: " + x1 + ", " + x2)
    }
    class B(x1: String = "hello", x2: String = "mom") extends A(x1, x2) {
      println("B: " + x1 + ", " + x2)
    }
    class C(x2: String = "dad") extends B(x2 = x2) {
      println("C: " + x1 + ", " + x2)
    }
    // scala> new C
    // A: hello, dad
    // B: hello, dad
    // C: hello, dad

Values passed as parameters to the superclass constructor are available in its body.

Scala 3 also [supports trait parameters](https://docs.scala-lang.org/scala3/reference/other-new-features/trait-parameters.html).

Note that overriding a `val` class parameter is deprecated / disallowed in Scala 3.
Doing so in Scala 2 can lead to surprising behavior.

### Use lazy vals

    abstract class A {
      lazy val x1: String
      lazy val x2: String = "mom"

      println("A: " + x1 + ", " + x2)
    }
    class B extends A {
      lazy val x1: String = "hello"

      println("B: " + x1 + ", " + x2)
    }
    class C extends B {
      override lazy val x2: String = "dad"

      println("C: " + x1 + ", " + x2)
    }
    // scala> new C
    // A: hello, dad
    // B: hello, dad
    // C: hello, dad

Note that abstract `lazy val`s are supported in Scala 3, but not in Scala 2.
In Scala 2, you can define an abstract `val` or `def` instead.

An exception during initialization of a lazy val will cause the right-hand side to be re-evaluated on the next access: see SLS 5.2.

Note that using multiple lazy vals creates a new risk: cycles among lazy vals can result in a stack overflow on first access.

### Use a nested object

Sometimes, uninitialized state in a subclass is accessed during construction of a superclass:

    class Adder {
      var sum = 0
      def add(x: Int): Unit = sum += x
      add(1)
    }
    class LogAdder extends Adder {
      private var added: Set[Int] = Set.empty
      override def add(x: Int): Unit = { added += x; super.add(x) }
    }

In this case the state can be initialized on demand by wrapping it into a local object:

    class Adder {
      var sum = 0
      def add(x: Int): Unit = sum += x
      add(1)
    }
    class LogAdder extends Adder {
      private object state {
        var added: Set[Int] = Set.empty
      }
      import state._
      override def add(x: Int): Unit = { added += x; super.add(x) }
    }

### Early definitions: deprecated

Scala 2 supports early definitinos, but they are deprecated in Scala 2.13 and unsupported in Scala 3.
See the [migration guide](https://docs.scala-lang.org/scala3/guides/migration/incompat-dropped-features.html#early-initializer) for more information.

